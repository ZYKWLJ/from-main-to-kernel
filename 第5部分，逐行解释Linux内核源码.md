# 第五部分，逐行代码讲解
# 第4章，ROOT_DEV = ORIG_ROOT_DEV;

```c
ROOT_DEV = ORIG_ROOT_DEV;
```
上文说到，我们的操作系统需要知道从哪里开始访问磁盘的文件系统。并专门为操作系统发现文件系统入口的行为定义了一个词——"挂载"。
下面的这行代码。就是进行的**挂载操作**。

```c
ROOT_DEV = ORIG_ROOT_DEV;
```

显然，我们将这个赋值语句两边的变量讲清楚就好了。

## 1. ORIG_ROOT_DEV
ORIG_ROOT_DEV：这是 **Bootloader**在内存中留下的一个 **标记**，它记录了根分区(文件系统的起点)在哪里。

什么？有点懵？没关系，我们来慢慢讲清楚。
我们先讲清楚 **Bootloader** 。
### 1.1 Bootloader
前文说到，操作系统分为两个部分：bootloader和kernel，真正对对接硬件、管理软件的部分是kernel。最初两者都是在硬盘上躺着，并没有在内存中运行，bios芯片将bootloader加载到内存中后，bootloader再来将kernel记载到内存中运行，这才是操作系统启动的整个过程。

那么，在Linux系统中，充当bootloader功能的，就是**源码下的boot目录**：
里面有3个文件，如下：
```c
├── boot
│   ├── bootsect.S
│   ├── setup.S
│   └── head.S
```
这三个文件各有功能，但最终**三者合力将kernel顺利地加载到内存中运行**，并**设置运行的基本环境**。

我按照执行顺序：bootsect.S -> setup.S -> head.S，依次讲解各文件内容和功能。

> 从这里，我们也就开始从main函数主线，开始散叶开花，依次讲解kernel的代码了。

### 1.2 bootsect.S
为了一目了然，我们先逐一讲解功能，后面载梳理出功能背后的原理以及代码实现。
#### 1.2.1 前置背景：

bootsect.s被编译后，最初躺在磁盘里面，他被BIOS加载到内存0x7c00地址处。

#### 1.2.2 功能：
```
1.将自身数据从0x7c00地址处的512B的启动区数据到0x90000处，并跳转至此处工作。
2.内存初始规划。将ds、ss、es设置为0x9000,sp设置为Oxff00，奠定了CPU访问三大段的基调。
3.加载硬盘中setup.s编译块到0x90200地址处。
4.加载硬盘中剩下的所有操作系统内核代码编译块到0x90000地址处。
```


### 1.2.ROOT_DEV
ROOT_DEV：这是**内核内部使用的全局变量**，后续代码（如**挂载根文件系统 mount_root()**）会读取这个变量，来决定**去哪个磁盘分区上找 ls、cat等等 程序**。



## 1.作用
简单来说，这段赋值代码的作用是：从 `BIOS / 引导加载程序（Bootloader）`留下的 `“遗产”` 中，`读取用户指定的 “根文件系统设备号”`，并将其赋值给`内核全局变量 ROOT_DEV`。