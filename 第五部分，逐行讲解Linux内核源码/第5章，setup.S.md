
# 1.前情回顾
好了，我们上面完成了main函数里面的第一行代码：
```
ROOT_DEV = ORIG_ROOT_DEV;
```
的讲解，并在其中开枝散叶，完成了bootsect.s的讲解。在其中也说到，Linux的整体的执行流程为：bootsect->setup->head->main()。
但是本书是为了以**main为主线讲解**，我们这里其实是跳过了**setup.s、head.s**,直接来到了main的第一行代码。

但是，直接讲解setup.s、head.s其实是有点强行灌知识的意味，让人不适。于是，我绕了个弯子，把大的面给你说明白了，再来讲小的过程，你就会明白的多。

好了，接下来我们就来补全跳过的setup.s和head.s。

首先我们来看看setup.s的代码吧。

>我们还是遵循老方法，先讲清楚作用，在深挖作用背后的原理，最后在回扣源码，这样比强行灌输源码更容易理解。

# 2.setup.s功能及解释

## 2.1 功能
setup.s的功能很简单，就是完成一些元数据信息的保存，然后把CPU切换到保护模式下去。

1. 将重要的元信息，如光标位置等，文字显示模式等从0地址处复制到0x90000地址处。

2. 将system模块从0x10000地址处复制到0x00000地址处。

3. 从16位实模式切换到32位保护模式(需要提前设置好GDT)。

4. 跳转到0x00000地址处，开始执行system模块的代码。

## 2.2 解释

### 0. BIOS的功能再议
BIOS除了加载引导区外，还涉及了一些其他的功能，如：

- 初始化硬件设备（如磁盘、键盘、显示器等）

- 加载引导程序（如 GRUB）

- 提供 BIOS 中断服务（如打印字符、读取磁盘等）

而这些硬件信息会被保存在低地址处，中断服务就是调用这些硬件信息的入口，你可以把它看成一个函数，仅此而已。

### 1. 将重要的元信息，如光标位置等，文字显示模式等从0地址处复制到0x90000地址处。

开机后到 setup 阶段，所有硬件（显示器、磁盘、键盘）**都由 BIOS 统一管理（准确的说，BIOS启动后，会接管这些硬件）**，**光标位置**（第几行第几列）、**文字显示模式**（如 80×25 字符模式、显示分辨率、颜色属性）、**磁盘参数**（每磁道扇区数）等硬件状态信息，都由 BIOS **维护在低地址内存**（0 地址段，**BIOS 数据区**） 中。而内核启动后会**完全接管所有硬件的管理权**（**不再依赖 BIOS 中断**），如果丢失这些状态信息，内核将无法知道**当前显示器的工作模式、光标在哪**，后续无法正常打印内核日志、响应用户输入。

那么为什么需要将这些元数据信息复制0x90000地址处呢？一个大胆的猜测就是后面低地址处的数据会被覆盖，这一步就是覆盖之前的信息保留，供后续内核使用。

实际上，也确实如此，因为，setup执行的第二步，就是将我们的system模块移动到低地址处，完成覆盖！一切都说的通了！

### 2. 将system模块从0x10000地址处复制到0x00000地址处.
为什么需要将system模块从0x10000地址处复制到0x00000地址处？

这是因为，system 内核编译链接时，**编译器 / 链接器默认内核会在 0x00000 运行**，因此**代码中所有的全局变量、函数调用、内存引用都是「基于 0x00000 的偏移地址」**（比如函数main的地址是 0x0000xxxx）。如果直接在 0x10000 运行，**内核会因为「地址引用错误」直接崩溃**（比如想访问 0x00001234，实际访问到 0x10000+0x1234，读取到垃圾数据）。


### 3. 从16位实模式切换到32位保护模式(需要提前设置好GDT)。
这是setup的关键，我们要把这点搞清楚不容易，慢慢来，先从CPU执行模式说起。

什么是CPU的执行模式？**就是CPU如何获得数据的物理地址的？** 这个简简单单的问题，实际涉及了悠久的历史。

在讲解各种模式之前，我们先来介绍一下CPU底层的模式切换原理。

#### 3.1 保存CPU重要元信息的CR0寄存器

CPU中有一个特别重要的寄存器——CR0寄存器。

> 开门见山，CPU 有3种执行模式：实模式、保护模式和分页模式。这三种模式涉及CPU的重要寄存器——**状态字寄存器CR0**的两个位：**PE、PG**。

![CR0寄存器](../img/setup/CR0寄存器.png)

|PE|PG|CPU执行模式|
|-|-|-|
|0|0|实模式（Real Mode）|
|1|0|保护模式（Protected Mode）|
|1|1|分页模式（Paging Mode）|

- **PE（Protection Enable）**：**保护使能位**，控制 CPU 是处于实模式还是**保护模式**。当 PE=0 时，CPU 处于实模式；当 PE=1 时，CPU 进入保护模式。

- **PG（Paging Enable）**：**分页使能位**，控制 CPU 是否启用**分页机制**。当 PG=0 时，CPU 不使用分页机制；当 PG=1 时，CPU 启用分页机制，进入分页模式。

> 所以我们看到，所谓CPU的各种执行模式，不过就是这几个位的开关而已，那么2^2=4才对，为啥只有3猴子那个模式？因为分页模式的基础是打开了保护模式。


#### 3.1 实模式
> PE=0,PG=0

实模式是 CPU 的**初始工作模式**，也是最简单的模式。在实模式下，**CPU 直接使用物理地址进行内存访问**，没有`任何内存保护机制`。实模式的内存寻址方式是通过**段寄存器和偏移地址**的组合来计算物理地址，**最大可寻址 1MB 内存（20 位地址总线）。**

又因为CPU按照pc寄存器里面的值作为执行地址，也就是说，对应关系为：

>pc=f(seg,ip) = seg << 4  + ip


##### 3.1.1段寄存器
那么这里seg段寄存器，在CPU内部是指的啥呢？

|seg段寄存器|作用|
|-|-|
|CS|代码段寄存器，存放当前执行代码所在的段地址|
|DS|数据段寄存器，存放当前数据所在的段地址|
|SS|栈段寄存器，存放当前栈所在的段地址|
|ES|额外数据段寄存器，存放当前额外数据所在的段地址|


#### 3.2 保护模式

> PE=1,PG=0

既然，实模式作为最初的模式，没有内存保护机制，所以理所当然的，保护模式就必须要开启。

----

保护模式是现代 CPU 的主要工作模式。在保护模式下，**CPU 使用段选择子和段描述符来进行内存访问**，具体来说，访问段寄存器里面的段选择子，将其值作为索引去访问**全局描述符表（GDT）**或**局部描述符表（LDT）**，获取对应的段描述符，然后根据段描述符中的基地址和偏移地址计算出物理地址。
保护模式相对于实模式为我们提供了**内存保护机制**。

那么提到了段选择子、段描述符、GDT、LDT等等，这些名词是指的啥？让我们慢慢来讲解：

##### 3.2.1 段寄存器的作用不同

在CPU中，有4个段寄存器：CS、DS、ES、SS。

那么在实模式上，这几个段寄存器里面存储的都是偏移地址，CPU直接将其右移4位，与偏移地址想加后，就直接得到了物理地址。

但是在保护模式下，这几个段寄存器里面存储的**不是偏移地址**，而是**段选择子**。

那么什么是段选择子呢？


##### 3.2.2 段选择子

段选择子是一个**16位的值**，作为索引，用于**选择GDT或LDT中的一个段描述符**。它的格式如下：

![段选择子](../img/setup/段选择子.png)

|字段|位数|作用|
|-|-|-|
|索引|3-15，13位|指向GDT或LDT中的一个段描述符|
|TI|2，1位|表指示位，0表示GDT，1表示LDT|
|RPL|0-1，2位|请求特权级，用于权限检查|


好了，这里又出现了一个**段描述符**，啥是**段描述符**呢？

#### 3.2.3 段描述符

一句话：段描述符是一个**8字节**的结构体，用于**描述一个段的属性和权限。**

![段描述符](../img/setup/段描述符.png)

我们从低字节到高字节依次讲解段描述符里面的内容：
 ##### 1.基地址低16位



| 个数 | 字段 | 位数 | 作用 |
| :--- | :--- | :--- | :--- |
| 1 | 基地址低16位 | 0-15，16位 | 段基地址的**低16位**（bit15~bit0），与高16位拼接成32位基地址，定义段在内存的起始位置 |
| 2 | 限长低16位 | 16-31，16位 | 段限长的**低16位**（bit31~bit16），与高4位拼接成20位限长，控制段的最大长度 |
| 3 | 基地址中8位 | 32-39，8位 | 段基地址的**中8位**（bit39~bit32，原表“高8位”为笔误），衔接低16位与高8位，补全32位基地址 |
| 4 | TYPE | 40-43，4位 | 段的具体类型与访问权限：<br>• S=1（应用段）：区分代码段（只读/可执行/一致）、数据段（只读/读写/扩展）<br>• S=0（系统段）：定义TSS、LDT、调用门/中断门等系统段类型 |
| 5 | S | 44，1位 | 描述符类型位（原表“0/1”写反）：<br>• 0 = **系统段**（TSS、LDT、门描述符等，用于系统管理）<br>• 1 = **应用段**（代码段/数据段，用于程序代码和数据） |
| 6 | DPL | 45-46，2位 | 描述符特权级（0~3级）：<br>• 00（0级）= 内核态（最高权限）<br>• 01（1级）= 设备驱动<br>• 10（2级）= 系统服务<br>• 11（3级）= 用户态（最低权限）<br>CPU访问时校验当前特权级（CPL），权限不足触发#GP异常 |
| 7 | P | 47，1位 | 存在位：<br>• 0 = 段**未加载**到物理内存（可能在磁盘交换区），访问触发#NP（段不存在）异常<br>• 1 = 段**已加载**，可正常访问，是虚拟内存的核心控制位 |
| 8 | 基地址高8位 | 48-55，8位 | 段基地址的**高8位**（bit55~bit48），与中8位、低16位拼接，最终形成**32位段基地址**（0x00000000~0xFFFFFFFF） |
| 9 | 限长高4位 | 56-59，4位 | 段限长的**高4位**（bit59~bit56，原表“56-63”为笔误），与低16位拼接成**20位段限长**（0x00000~0xFFFFF） |
| 10 | AVL | 60，1位 | 系统软件可用位：CPU不使用，供操作系统/编译器自定义标记段属性 |
| 11 | 0 | 61，1位 | 保留位：必须置0，CPU忽略该位，无实际功能 |
| 12 | B/D | 62，1位 | 默认操作数大小位：<br>• 代码段（D位）：0=16位操作数/地址，1=32位操作数/地址<br>• 数据段（B位）：0=16位栈指针（SP），1=32位栈指针（ESP） |
| 13 | G | 63，1位 | 粒度位：<br>• 0 = 段限长以**字节**为单位（最大1MB）<br>• 1 = 段限长以**4KB（页）**为单位（最大4GB） |

---
 

##### 核心拼接公式（必记）

- **32位段基地址** = 基地址高8位(48-55) + 基地址中8位(32-39) + 基地址低16位(0-15)

- **20位段限长** = 限长高4位(56-59) + 限长低16位(16-31)

- **段实际长度** = 段限长 × (G=0?1字节:4KB)

好了，有了段描述符，我们就能知道段的基地址了！然后通过下述公式计算物理地址：

>PC=f(seg,ip)=gdt(seg)中的段基地址组合+ip

#### 3.2.4 为啥叫保护模式？

保护模式相对于实模式的最大优势就是**内存保护机制**。

内存保护机制通过**段描述符中的DPL（描述符特权级）和P（存在位）**来实现：

- **DPL（描述符特权级）**：定义了段的访问权限，CPU 在访问内存时会检查当前特权级（CPL）是否满足段的 DPL 要求，权限不足会触发异常，防止非法访问。

- **P（存在位）**：定义了段是否存在于物理内存中，0 表示段不存在（可能在磁盘交换区），1 表示段已加载到物理内存，可正常访问。

通过这些机制，保护模式能够有效防止程序越权访问内存，保障系统的稳定性和安全性。

----
在此，我们先总结一下实模式、保护模式(未开启分页)下的内存管理方式：

|CPU执行模式|内存管理方式|解释|
|-|-|-|
|实模式|分段寻址|是8086实模式的寻址方式，存在您列出的所有问题。|
|保护模式(未开启分页)|段式内存管理|是保护模式下操作系统利用分段硬件提供的内存管理方案，它解决了保护、隔离等问题（但仍存在碎片问题）。|

其实，仅仅通过开启保护模式，启动特权级访问，确实可以解决一些安全问题，但是也有段式管理与生俱来的一些毛病:

##### 3.3.1 内存碎片严重

分段模式的段长度可变，导致**外部碎片严重**。|

##### 3.3.2 分段交换开销大

分段在交换时，**交换整个段（可能很大，几MB）到磁盘，I/O开销大。**

同时，如果只需要访问段中的一小部分，也必须加载整个段。

##### 3.3.3 地址空间布局不够灵活

段有基址和界限，程序的不同部分（代码、数据、堆、栈）**必须连续存放。**

##### 3.3.4 内存管理（对操作系统）复杂

OS需要管理不同大小的内存块，类似动态分区分配，算法复杂。


好了，有这么多问题，我们这才引出了分页模式：


#### 3.3 分页模式
> PE=1,PG=1

分页模式是在保护模式的基础上，进一步启用分页机制的工作模式。在分页模式下，**内存被划分为固定大小的页（通常为 4KB）**，并通过页表进行虚拟地址到物理地址的映射。

正是因为上面的分段寻址和段式内存管理模式的缺点，我们要想让整个操作系统高效，就必须还要有分页模式：

>不要忘记，我们所有的执行模式，都是解决一个问题：CPU如何得到物理地址。

那么既然分页模式需要再分段模式下，进一步开启分页功能，所以上述分段模式下得到的最后的地址，就不是物理地址，开启分页模式后，我们叫做：线性地址。

在分页模式下，会将32位线性地址转化为：

>高10位，中10位，低12位

|线性地址被划分为3部分|各部分的功能|
|-|-|
|高10位|用于索引页目录，找到对应的页目录项（PDE）。|
|中间10位|用于具体索引页表，找到对应的页表项（PTE）。将PTE里面的**页框号左移12位得到物理页框号**。|
|低12位|偏移地址，与PTE中对应的页框号左移12位得到物理页框号想加，得到物理地址。|
 
那么这里出现了PDE(页目录项)、PTE(页表项)，这都是些啥结构？

---

##### 3.3.1 页目录项（PDE）

![PDE、PTE同样的结构](../img/setup/PDE、PTE.png)

PDE 是**页目录表中的条目**，用于定位**页表**的**物理地址**，核心字段如下（从高位到低位，对应图中 31~0 位）：
 
| 字段 | 位位置 | 核心解释 |
|------|--------|----------|
| **页表地址** | 31~12 | 存储**页表的物理基地址**（页表按4KB对齐，**低12位为0，仅高20位为有效地址**），CPU据此找到**对应页表**。 |
| **AVL** | 11~9 | 操作系统/软件自定义位，硬件不使用，可用于存储页表管理的额外信息。 |
| **G** | 8 | 全局位，置1时该页表项对应的页为**全局页**，TLB刷新时不失效（用于内核等全局共享页）。 |
| **0** | 7 | 保留位，必须为0，硬件未定义用途。 |
| **D** | 6 | 脏位，置1表示该页表**已被修改**（页表本身的写操作，非页内数据），仅PDE有此位。 |
| **A** | 5 | 访问位，置1表示该页表**已被访问**（CPU读取PDE时自动置1），用于页替换算法。 |
| **PCD** | 4 | 页缓存禁用位，置1时该页表**不使用CPU缓存**，直接访问内存（用于MMIO等不可缓存区域）。 |
| **PWT** | 3 | 页写通位，置1时该页表采用**写通缓存策略**（写操作同时更新缓存和内存），0为写回策略。 |
| **U/S** | 2 | 用户/超级用户位，置1时**用户态程序可访问**该页表，0仅内核态（超级用户）可访问。 |
| **R/W** | 1 | 读写位，置1时该页表**可读写**，0为只读（写操作触发页异常）。 |
| **P** | 0 | 存在位，置1表示该**页表已加载到物理内存**，0表示页表不在内存（触发缺页异常）。 |

---
##### 3.3.1 页表项（PTE）

| 字段 | 位位置 | 核心解释 |
|------|--------|----------|
| **页物理地址** | 31~12 | 存储**物理页的基地址**（物理页按4KB对齐，**低12位为0，仅高20位为有效地址**），CPU据此找到线性地址对应的**物理内存页**。 |
| **AVL** | 11~9 | 操作系统/软件自定义位，硬件不使用，可存储页的额外属性（如页类型、权限扩展）。 |
| **G** | 8 | 全局位，置1时该物理页为**全局页**，TLB刷新时不失效（内核全局页常用）。 |
| **0** | 7 | 保留位，必须为0，硬件未定义用途。 |
| **D** | 6 | 脏位，置1表示该**物理页已被修改**（页内数据写操作触发），用于写回内存时判断是否需要刷盘。 |
| **A** | 5 | 访问位，置1表示该**物理页已被访问**（CPU读取/写入页内数据时自动置1），用于页替换算法（如LRU）。 |
| **PCD** | 4 | 页缓存禁用位，置1时该物理页**不使用CPU缓存**，直接访问内存（用于MMIO、设备寄存器等）。 |
| **PWT** | 3 | 页写通位，置1时该物理页采用**写通缓存策略**，0为写回策略（写操作先更新缓存，后续批量写回内存）。 |
| **U/S** | 2 | 用户/超级用户位，置1时**用户态程序可访问**该物理页，0仅内核态可访问（保护内核内存）。 |
| **R/W** | 1 | 读写位，置1时该物理页**可读写**，0为只读（用户态写只读页触发页异常，内核态可忽略）。 |
| **P** | 0 | 存在位，置1表示该**物理页已加载到内存**，0表示页在磁盘（触发缺页异常，由操作系统加载）。 |

---

### 关键区别（PDE vs PTE）
1. **地址指向**：PDE 指向**页表**，PTE 指向**物理页**；
2. **D 位含义**：PDE 的 D 位是**页表本身的脏位**，PTE 的 D 位是**物理页数据的脏位**；
3. **核心作用**：PDE 完成**虚拟地址→页表”的一级映射**，PTE 完成**虚拟地址→物理页”的二级映射**。

---

#### 3.4 为什么说分页模式下，可以解决内存碎片问题？

这是一个很好的问题。分页模式本身**并不直接“解决”传统意义上的外部内存碎片问题**，而是通过一种**根本性的设计**，彻底**避免了外部碎片的产生**，从而让“碎片问题”不复存在。

为了理解这一点，我们需要区分两种碎片，并对比分页和分段两种内存管理方式。

##### 3.4.1. 两种内存碎片
- **内部碎片**：指分配给进程的**内存块内部**未被使用的部分。例如，进程申请了100KB，系统分配了128KB的固定块，那28KB就是内部碎片。
- **外部碎片**：指内存中分散的、**总空间足够但无法被利用**的小块空闲内存。例如，内存中有三块不连续的50MB空闲空间，但一个需要120MB的进程却无法被加载，因为这些空闲空间不连续。

**传统意义上的“碎片问题”通常指的是外部碎片。**

##### 3.4.2. 分段模式下的碎片问题（对比才能理解）
在分段模式下，内存被划分成**长度不等的逻辑段**（如代码段、数据段、堆栈段）。系统为每个段寻找一块连续的物理内存。
- **问题**：随着进程的加载和卸载，内存中会留下许多**大小不一的空闲孔洞**。
- **后果**：即使所有空闲孔洞的总和大于新进程所需，但因为它们不连续，新进程也无法加载。这就是**外部碎片**。
- **解决方案（代价高昂）**：操作系统需要定期进行**内存压缩**，即移动所有已分配的内存，把空闲区域合并成一大块连续空间。这个过程非常耗时，且会降低系统性能。

##### 3.4.3. 分页模式如何“解决”（更准确说是“避免”）碎片问题
分页模式采用了一种完全不同的思路：

1. **物理内存等分**：将物理内存划分为一系列**大小固定、相等的小单元**，称为**页框**。
2. **逻辑地址等分**：将进程的逻辑地址空间也划分为同样大小的单元，称为**页**。
3. **地址映射机制**：操作系统为每个进程维护一张**页表**。页表的作用是：将进程的**逻辑页号**映射到物理内存的**任意物理页框号**。

##### 3.4.4 关键特性：
- **连续性要求的消除**：一个进程的多个页，**不需要**在物理内存中连续存放。第一页可以在页框10，第二页可以在页框50，第三页可以在页框5。
- **分配粒度小**：以页（通常是4KB）为单位进行分配，远小于分段中的整个段（可能是几MB或几GB）。

##### 3.4.5  为什么没有外部碎片？
- **空闲管理简单**：系统只需要维护一个**空闲页框列表**。当需要为新页分配内存时，只需从列表中取出**任何一个**空闲页框即可。
- **“总空间足够即可分配”**：只要空闲页框的**总数**大于等于进程所需的页数，无论这些页框在物理上位于何处（0x1000, 0x5000, 0xA000...），进程都能被成功加载。页表负责建立这些不连续的页框与连续逻辑地址空间的映射关系。
- **没有“无法利用的小洞”**：最小的分配单元是页框。一个页框要么完全空闲，要么完全被占用。任何空闲页框对任何需要一页的请求都同样可用。不存在“一个50KB的请求，但最大空闲块只有49KB”的情况（除非进程总需求小于一页，但那是内部碎片）。

##### 3.4.6  付出的代价：内部碎片
分页模式并非完美，它用**内部碎片**替代了**外部碎片**。
- 进程的最后一个页很少能完全填满。平均而言，每个进程会浪费**半页**大小的内存。
- 例如，一个大小为10.1KB的进程，在4KB的页大小下，需要3个页（12KB），其中有大约1.9KB的内部碎片。
- **权衡**：这是一个经过深思熟虑的权衡。内部碎片是可预测、可管理的（浪费量≤页大小），而且不会像外部碎片那样导致系统无法分配内存。通过选择合理的页大小（如4KB），可以将内部碎片的平均开销控制在可接受的范围内。

##### 3.4.7 总结
| 特性 | 分段 | 分页 |
| :--- | :--- | :--- |
| **内存划分** | 长度可变的逻辑段 | 固定大小的页 |
| **连续性要求** | **需要**连续物理内存 | **不需要**连续物理内存 |
| **主要碎片** | **外部碎片**严重 | **内部碎片**（少量可控） |
| **碎片“解决”** | 需要内存压缩（耗时） | **通过设计根本避免** |
| **分配粒度** | 大（整个段） | 小（单个页） |

因此，准确的说法是：**分页内存管理模式通过取消进程内存必须连续的硬性要求，并辅以固定大小的页分配机制，彻底消除了外部内存碎片产生的条件，从而解决了外部碎片导致内存无法有效利用的根本问题。** 这是现代操作系统（如Linux, Windows, macOS）普遍采用分页机制的核心原因之一。



### 4. 跳转到0x00000地址处，开始执行system模块的代码。

这是理所当然的，执行流就是BIOS->bootsect->setup->system

# 3. setup.S源码讲解

## 3.1 setup.S全部源码
```s
	.code16
	.equ INITSEG, 0x9000	# we move boot here - out of the way
	.equ SYSSEG, 0x1000	# system loaded at 0x10000 (65536).
	.equ SETUPSEG, 0x9020	# this is the current segment

	.global _start, begtext, begdata, begbss, endtext, enddata, endbss
	.text
	begtext:
	.data
	begdata:
	.bss
	begbss:
	.text

	ljmp $SETUPSEG, $_start	
_start:
	mov %cs,%ax
	mov %ax,%ds
	mov %ax,%es

# print some message

	mov $0x03, %ah
	xor %bh, %bh
	int $0x10

	mov $29, %cx
	mov $0x000b,%bx
	mov $msg2,%bp
	mov $0x1301, %ax
	int $0x10
# ok, the read went well so we get current cursor position and save it for
# posterity.
	mov	$INITSEG, %ax	# this is done in bootsect already, but...
	mov	%ax, %ds
	mov	$0x03, %ah	# read cursor pos
	xor	%bh, %bh
	int	$0x10		# save it in known place, con_init fetches
	mov	%dx, %ds:0	# it from 0x90000.
# Get memory size (extended mem, kB)

	mov	$0x88, %ah 
	int	$0x15
	mov	%ax, %ds:2

# Get video-card data:

	mov	$0x0f, %ah
	int	$0x10
	mov	%bx, %ds:4	# bh = display page
	mov	%ax, %ds:6	# al = video mode, ah = window width

# check for EGA/VGA and some config parameters

	mov	$0x12, %ah
	mov	$0x10, %bl
	int	$0x10
	mov	%ax, %ds:8
	mov	%bx, %ds:10
	mov	%cx, %ds:12

# Get hd0 data

	mov	$0x0000, %ax
	mov	%ax, %ds
	lds	%ds:4*0x41, %si
	mov	$INITSEG, %ax
	mov	%ax, %es
	mov	$0x0080, %di
	mov	$0x10, %cx
	rep
	movsb

# Get hd1 data

	mov	$0x0000, %ax
	mov	%ax, %ds
	lds	%ds:4*0x46, %si
	mov	$INITSEG, %ax
	mov	%ax, %es
	mov	$0x0090, %di
	mov	$0x10, %cx
	rep
	movsb

## modify ds
	mov $INITSEG,%ax
	mov %ax,%ds
	mov $SETUPSEG,%ax
	mov %ax,%es

##show cursor pos:
	mov $0x03, %ah 
	xor %bh,%bh
	int $0x10
	mov $11,%cx
	mov $0x000c,%bx
	mov $cur,%bp
	mov $0x1301,%ax
	int $0x10

#show detail
	mov %ds:0 ,%ax
	call print_hex
	call print_nl

#show memory size
	mov $0x03, %ah
	xor %bh, %bh
	int $0x10
	mov $12, %cx
	mov $0x000a, %bx
	mov $mem, %bp
	mov $0x1301, %ax
	int $0x10

##show detail
	mov %ds:2 , %ax
	call print_hex

#show 
	mov $0x03, %ah
	xor %bh, %bh
	int $0x10
	mov $25, %cx
	mov $0x000d, %bx
	mov $cyl, %bp
	mov $0x1301, %ax
	int $0x10
 
	mov %ds:0x80, %ax
	call print_hex
	call print_nl

 
	mov $0x03, %ah
	xor %bh, %bh
	int $0x10
	mov $8, %cx
	mov $0x000e, %bx
	mov $head, %bp
	mov $0x1301, %ax
	int $0x10
 
	mov %ds:0x82, %ax
	call print_hex
	call print_nl

 
	mov $0x03, %ah
	xor %bh, %bh
	int $0x10
	mov $8, %cx
	mov $0x000f, %bx
	mov $sect, %bp
	mov $0x1301, %ax
	int $0x10
 
	mov %ds:0x8e, %ax
	call print_hex
	call print_nl
 
	mov	$0x01500, %ax
	mov	$0x81, %dl
	int	$0x13
	jc	no_disk1
	cmp	$3, %ah
	je	is_disk1
no_disk1:
	mov	$INITSEG, %ax
	mov	%ax, %es
	mov	$0x0090, %di
	mov	$0x10, %cx
	mov	$0x00, %ax
	rep
	stosb
is_disk1:

# now we want to move to protected mode ...

	cli			# no interrupts allowed ! 

# first we move the system to its rightful place

	mov	$0x0000, %ax
	cld			# 'direction'=0, movs moves forward
do_move:
	mov	%ax, %es	# destination segment
	add	$0x1000, %ax
	cmp	$0x9000, %ax
	jz	end_move
	mov	%ax, %ds	# source segment
	sub	%di, %di
	sub	%si, %si
	mov 	$0x8000, %cx
	rep
	movsw
	jmp	do_move

# then we load the segment descriptors

end_move:
	mov	$SETUPSEG, %ax	# right, forgot this at first. didnt work :-)
	mov	%ax, %ds
	lidt	idt_48		# load idt with 0,0
	lgdt	gdt_48		# load gdt with whatever appropriate


	inb     $0x92, %al	# open A20 line(Fast Gate A20).
	orb     $0b00000010, %al
	outb    %al, $0x92

	mov	$0x11, %al		# initialization sequence(ICW1)
					# ICW4 needed(1),CASCADE mode,Level-triggered
	out	%al, $0x20		# send it to 8259A-1
	.word	0x00eb,0x00eb		# jmp $+2, jmp $+2
	out	%al, $0xA0		# and to 8259A-2
	.word	0x00eb,0x00eb
	mov	$0x20, %al		# start of hardware int's (0x20)(ICW2)
	out	%al, $0x21		# from 0x20-0x27
	.word	0x00eb,0x00eb
	mov	$0x28, %al		# start of hardware int's 2 (0x28)
	out	%al, $0xA1		# from 0x28-0x2F
	.word	0x00eb,0x00eb		#               IR 7654 3210
	mov	$0x04, %al		# 8259-1 is master(0000 0100) --\
	out	%al, $0x21		#				|
	.word	0x00eb,0x00eb		#			 INT	/
	mov	$0x02, %al		# 8259-2 is slave(       010 --> 2)
	out	%al, $0xA1
	.word	0x00eb,0x00eb
	mov	$0x01, %al		# 8086 mode for both
	out	%al, $0x21
	.word	0x00eb,0x00eb
	out	%al, $0xA1
	.word	0x00eb,0x00eb
	mov	$0xFF, %al		# mask off all interrupts for now
	out	%al, $0x21
	.word	0x00eb,0x00eb
	out	%al, $0xA1


	mov	%cr0, %eax	# get machine status(cr0|MSW)	
	bts	$0, %eax	# turn on the PE-bit 
	mov	%eax, %cr0	# protection enabled
				
				# segment-descriptor        (INDEX:TI:RPL)
	.equ	sel_cs0, 0x0008 # select for code segment 0 (  001:0 :00) 
	ljmp	$sel_cs0, $0	# jmp offset 0 of code segment 0 in gdt

empty_8042:
	.word	0x00eb,0x00eb
	in	$0x64, %al	# 8042 status port
	test	$2, %al		# is input buffer full?
	jnz	empty_8042	# yes - loop
	ret

gdt:
	.word	0,0,0,0		# dummy

	.word	0x07FF		# 8Mb - limit=2047 (2048*4096=8Mb)
	.word	0x0000		# base address=0
	.word	0x9A00		# code read/exec
	.word	0x00C0		# granularity=4096, 386

	.word	0x07FF		# 8Mb - limit=2047 (2048*4096=8Mb)
	.word	0x0000		# base address=0
	.word	0x9200		# data read/write
	.word	0x00C0		# granularity=4096, 386

idt_48:
	.word	0			# idt limit=0
	.word	0,0			# idt base=0L

gdt_48:
	.word	0x800			# gdt limit=2048, 256 GDT entries
	.word   512+gdt, 0x9		# gdt base = 0X9xxxx, 
	# 512+gdt is the real gdt after setup is moved to 0x9020 * 0x10
print_hex:
	mov $4,%cx
	mov %ax,%dx

print_digit:
	rol $4,%dx	#循环以使低4位用上，高4位移至低4位
	mov $0xe0f,%ax #ah ＝ 请求的功能值，al = 半个字节的掩码
	and %dl,%al
	add $0x30,%al
	cmp $0x3a,%al
	jl outp
	add $0x07,%al

outp:
	int $0x10
	loop print_digit
	ret
#打印回车换行
print_nl:
	mov $0xe0d,%ax
	int $0x10
	mov $0xa,%al
	int $0x10
	ret

msg2:
	.byte 13,10
	.ascii "Now we are in setup ..."
	.byte 13,10,13,10
cur:
	.ascii "Cursor POS:"
mem:
	.ascii "Memory SIZE:"
cyl:
	.ascii "KB"
	.byte 13,10,13,10
	.ascii "HD Info"
	.byte 13,10
	.ascii "Cylinders:"
head:
	.ascii "Headers:"
sect:
	.ascii "Secotrs:"
.text
endtext:
.data
enddata:
.bss
endbss:
```
