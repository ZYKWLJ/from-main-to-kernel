# 1.前情回顾

上文说到，操作系统要运行，就必须加载到内存中，经过bootsect.S加载，操作系统成功运行在内存中了；但是一些重要的设置还没有完成，并且CPU依然工作在实模式下，所以我们进行了setup.S阶段，完成元数据保存、system段的位移、进入保护模式前的必要操作等工作，如设置GDT表等。

好了，那么接下来，我们CPU要跑到哪里去执行呢？

我们通过代码来看：

```s
ljmp	$sel_cs0, $0 # sel_cs0=0x0008
```
## 1.1setup后跳转到哪里？

### 1.1.1段基地址：

将sel_cs0解释为1-00-0，可以看到，我们找到GDT的索引为1的描述符表项：
```s
    # (2) 代码段描述符（索引 1，选择子 0x0008）
	.word	0x07FF		# 8Mb - limit=2047 (2048*4096=8Mb)
	.word	0x0000		# base address=0
	.word	0x9A00		# code read/exec
	.word	0x00C0		# granularity=4096, 386
```

我们按照描述符组成挨个对比，得到8字节如下：

>FF-70-00-00-00-A9-0C-00

16~31位置：00-00
32~39位置：00
48~63位置：00

![段描述符](../img/setup/段描述符.png)

所以基地址为0x0000.

### 1.1.2.偏移地址
显然，`ljmp	$sel_cs0, $0`中,偏移地址为0.

>所以，经过setup.S后，我们CPU转向0x0000执行 代码，而那里刚好是setup.S移过去的System(head模块)！一切都串起来了！


# 2.head.s功能及原理
