# 1.对应main中的功能
本节讲解main中的：
- 5.内存初始化

功能：

# 2.源码讲解
## 2.1 mem_init的大致讲解
main.c中就是一个函数调用：
```c
mem_init(main_memory_start,memory_end);
```
真正实现如下：
[mem_init的实现](../src/mm/memory.c)

```c
void mem_init(long start_mem, long end_mem)
{
	int i;
	HIGH_MEMORY = end_mem;
	for (i=0 ; i<PAGING_PAGES ; i++)
		mem_map[i] = USED;
	i = MAP_NR(start_mem);
	end_mem -= start_mem;
	end_mem >>= 12;
	while (end_mem-->0)
		mem_map[i++]=0;
}
```
而这个短短的初始化函数，里面藏着了Linux内存管理的精髓！


## 2.4 mem_init的逐行代码讲解
首先，我们直接看main中引用的`mem_init`函数：
```c
void mem_init(long start_mem, long end_mem) //参数是内存的起始地址和结束地址
{
	int i;

	HIGH_MEMORY = end_mem;//高地址等于end_mem
	for (i=0 ; i<PAGING_PAGES ; i++)//一共有PAGING_PAGES个页面
		mem_map[i] = USED;//页面已经被使用
	i = MAP_NR(start_mem);
	end_mem -= start_mem;
	end_mem >>= 12;
	while (end_mem-->0)
		mem_map[i++]=0;
}
```
### 2.4.1 这里出现的`HIGH_MEMORY`、 `end_mem`是指啥？
HIGH_MEMORY是memory.c里面的静态变量
```c
static long HIGH_MEMORY = 0;
```
end_mem是参数。

---

### 2.4.2 这里出现的`PAGING_PAGES`是指啥？

如下，`PAGING_MEMORY`指的分页内存大小，15MB。为啥是15MB？

> 因为内核和缓冲区占用了1MB，剩下的全是分页内存。

### 2.4.3 那`PAGING_PAGES`指的是分页内存大小除以页大小，即15MB除以`4KB`，得到3840页。

```c
#define PAGING_MEMORY (15*1024*1024)
#define PAGING_PAGES (PAGING_MEMORY>>12)
```

---

###  2.4.4 那这里的`USED`是指啥？
```c
#define USED 100
```
表示当前的物理页面已经被使用了。

###  2.4.5 mem_map指的啥？
```c
static unsigned char mem_map [ PAGING_PAGES ] = {0,};
```
mem_map是一个存放`物理页面使用状态`的`字节数组`，每个元素表示一个`物理页面的使用状态`。
那显然，USED就代表页面使用了！
这里初始化全部已经使用了？！！

### 2.4.6 那这里的`i = MAP_NR(start_mem);`是指啥？

>指的是，将第一个物理页面的编号赋值给i。

```c
#define LOW_MEM 0x100000
#define MAP_NR(addr) (((addr)-LOW_MEM)>>12)
```
显然，这里的`MAP_NR(start_mem)`是指`start_mem`对应的`物理页面编号。`

#### 2.4.6.1 为啥这里需要`- LOW_MEM`？
因为0x100000下面是内核，我们不管。

#### 2.4.6.2 为啥这里右移12位？
>12位，是4kb。
因为`每个页面是4KB`，所以右移12位就是除以4KB，得到`页面编号`。


### 2.4.7 计算可用物理页面的数量
```c
end_mem -= start_mem;
end_mem >>= 12;
```
这里指的是， 将`end_mem`减去`start_mem`，得到的就是`可用物理内存的大小`，单位是`字节`。
同时，将`end_mem`右移12位，得到的就是`可用物理页面的数量`。

### 2.4.8 将每一个可用物理页面的状态设置为0
```c
while (end_mem-->0)
	mem_map[i++]=0;
```
### 2.4.9 mem_init作用总结
所以`mem_init`就很简单了,工作为：
>将传入的`start_mem`和`end_mem`转换为`物理页面编号`，将`mem_map`中对应的`物理页面状态`设置为0。

而我么main中，调用的参数为：
```c
mem_init(main_memory_start,memory_end);
```
可见，这就是将主内存进行物理页面编号呢！


